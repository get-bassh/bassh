#!/bin/bash

# bassh: Deploy static sites via shared Cloudflare infrastructure
# Users don't need their own Cloudflare account - deploys to your worker

set -e

# ============================================================
# CONFIGURATION
# ============================================================
WORKER_URL="${BASSH_API:-}"
API_KEY="${BASSH_KEY:-}"
# ============================================================

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

# Defaults
DIR="."
PASSWORD=""
PROJECT_NAME=""
EMAILS=""
DOMAIN=""
CUSTOM_DOMAIN=""
OTP_EMAILS=""
DELETE_MODE=false
LIST_MODE=false
REGISTER_MODE=false
ME_MODE=false
KEY_MODE=false
KEY_REGENERATE=false
UNINSTALL_MODE=false
REGISTER_USERNAME=""
INVITE_CODE=""
FORMS_MODE=false
FORMS_FORMAT=""
FORMS_CLEAR=false
FORMS_COUNT=false

# Machine ID for one-account-per-computer enforcement
CONFIG_DIR="$HOME/.bassh"
MACHINE_ID_FILE="$CONFIG_DIR/machine-id"

get_machine_id() {
  # Create config directory if needed
  mkdir -p "$CONFIG_DIR"

  # Return existing machine ID if present
  if [[ -f "$MACHINE_ID_FILE" ]]; then
    cat "$MACHINE_ID_FILE"
    return
  fi

  # Try to get hardware UUID (macOS)
  if [[ "$(uname)" == "Darwin" ]]; then
    HWID=$(ioreg -rd1 -c IOPlatformExpertDevice 2>/dev/null | grep -oE '"IOPlatformUUID" = "[^"]+"' | cut -d'"' -f4)
    if [[ -n "$HWID" ]]; then
      echo "$HWID" > "$MACHINE_ID_FILE"
      echo "$HWID"
      return
    fi
  fi

  # Try /etc/machine-id (Linux)
  if [[ -f "/etc/machine-id" ]]; then
    HWID=$(cat /etc/machine-id)
    echo "$HWID" > "$MACHINE_ID_FILE"
    echo "$HWID"
    return
  fi

  # Generate random ID as fallback
  HWID=$(head -c 32 /dev/urandom | xxd -p | tr -d '\n' | head -c 32)
  echo "$HWID" > "$MACHINE_ID_FILE"
  echo "$HWID"
}

# Parse arguments
while [[ $# -gt 0 ]]; do
  case $1 in
    register)
      REGISTER_MODE=true
      shift
      # Parse register arguments
      while [[ $# -gt 0 ]]; do
        case $1 in
          --invite|-i)
            INVITE_CODE="$2"
            shift 2
            ;;
          -*)
            echo -e "${RED}Unknown option: $1${NC}"
            exit 1
            ;;
          *)
            REGISTER_USERNAME="$1"
            shift
            ;;
        esac
      done
      break
      ;;
    me)
      ME_MODE=true
      shift
      ;;
    uninstall)
      UNINSTALL_MODE=true
      shift
      ;;
    key)
      KEY_MODE=true
      if [[ "${2:-}" == "--regenerate" || "${2:-}" == "-r" ]]; then
        KEY_REGENERATE=true
        shift 2
      else
        shift
      fi
      ;;
    forms)
      FORMS_MODE=true
      shift
      while [[ $# -gt 0 ]]; do
        case $1 in
          --csv) FORMS_FORMAT="csv"; shift ;;
          --json) FORMS_FORMAT="json"; shift ;;
          --clear) FORMS_CLEAR=true; shift ;;
          --count) FORMS_COUNT=true; shift ;;
          -n|--name) PROJECT_NAME="$2"; shift 2 ;;
          *) shift ;;
        esac
      done
      break
      ;;
    --password|-p)
      PASSWORD="$2"
      shift 2
      ;;
    --name|-n)
      PROJECT_NAME="$2"
      shift 2
      ;;
    --emails|-e)
      EMAILS="$2"
      shift 2
      ;;
    --domain|-d)
      DOMAIN="$2"
      shift 2
      ;;
    --custom-domain)
      CUSTOM_DOMAIN="$2"
      shift 2
      ;;
    --otp|-o)
      OTP_EMAILS="$2"
      shift 2
      ;;
    --delete|-D)
      DELETE_MODE=true
      shift
      ;;
    --list|-l)
      LIST_MODE=true
      shift
      ;;
    --help|-h)
      echo "bassh - Deploy a static site in one command"
      echo ""
      echo "Usage: bassh [command] [directory] [options]"
      echo ""
      echo "Commands:"
      echo "  register <username>       Create an account (with invite code or manual setup)"
      echo "  me                        Show current user info"
      echo "  key                       Show your API key"
      echo "  key --regenerate          Generate a new API key (invalidates old)"
      echo "  forms -n <project>        View form submissions for a project"
      echo "  uninstall                 Delete account, all sites, and remove CLI"
      echo ""
      echo "Registration Options:"
      echo "  -i, --invite <code>       Use invite code (format: subdomain:secret)"
      echo ""
      echo "Deploy Options:"
      echo "  -p, --password <pass>     Add AES-256-GCM encrypted password protection"
      echo "  -o, --otp <emails>        Email magic link protection (comma-separated emails/domains)"
      echo "  -e, --emails <list>       Restrict via Cloudflare Access (comma-separated emails)"
      echo "  -d, --domain <domain>     Allow all emails from domain via Cloudflare Access"
      echo "  -n, --name <name>         Project name (auto-generated if not provided)"
      echo "  --custom-domain <domain>  Attach a custom domain (e.g., docs.example.com)"
      echo "  -l, --list                List your projects"
      echo "  -D, --delete              Delete a project (requires -n)"
      echo "  -h, --help                Show this help"
      echo ""
      echo "Registration:"
      echo "  # With invite code (one code does everything)"
      echo "  bassh register alice --invite bob-rietveld:secret123"
      echo ""
      echo "  # Without invite code (requires BASSH_API to be set)"
      echo "  export BASSH_API=https://bassh-api.example.workers.dev"
      echo "  bassh register alice"
      echo ""
      echo "Deploy Examples:"
      echo "  bassh                                      # Deploy current directory"
      echo "  bassh ./my-site                            # Deploy specific directory"
      echo "  bassh -p secret123                         # With password"
      echo "  bassh -o \"a@x.com,b@y.com\"                 # Email magic link (via Resend)"
      echo "  bassh -o \"@company.com\"                    # Anyone @company.com gets magic link"
      echo "  bassh -e \"a@x.com,b@y.com\"                 # Cloudflare Access email restriction"
      echo "  bassh -d \"@company.com\"                    # Cloudflare Access domain restriction"
      echo "  bassh --custom-domain docs.example.com     # With custom domain"
      echo "  bassh -l                                   # List your projects"
      echo "  bassh -D -n my-project                     # Delete a project"
      echo ""
      echo "Other Commands:"
      echo "  bassh me                       # Show your username and API URL"
      echo "  bassh key                      # Show your API key"
      echo "  bassh key --regenerate         # Get a new API key"
      echo "  bassh uninstall                # Remove account and all data"
      echo ""
      echo "Form Submissions:"
      echo "  bassh forms -n my-project      # View submissions"
      echo "  bassh forms -n my-project --csv    # Export as CSV"
      echo "  bassh forms -n my-project --json   # Export as JSON"
      echo "  bassh forms -n my-project --count  # Show count only"
      echo "  bassh forms -n my-project --clear  # Delete all submissions"
      echo ""
      echo "Environment:"
      echo "  BASSH_API    The deployment API URL (set automatically with invite code)"
      echo "  BASSH_KEY    Your API key (saved automatically during registration)"
      exit 0
      ;;
    *)
      DIR="$1"
      shift
      ;;
  esac
done

# Handle register mode (before URL check since invite code provides URL)
if [[ "$REGISTER_MODE" == true ]]; then
  if [[ -z "$REGISTER_USERNAME" ]]; then
    echo -e "${RED}Error: Username required${NC}"
    echo "Usage: bassh register <username> [--invite <code>]"
    echo ""
    echo "Examples:"
    echo "  bassh register alice --invite bob-rietveld:secret123"
    echo "  bassh register alice  # If BASSH_API is already set"
    exit 1
  fi

  # Parse invite code if provided (format: subdomain:registrationcode)
  if [[ -n "$INVITE_CODE" ]]; then
    if [[ "$INVITE_CODE" != *":"* ]]; then
      echo -e "${RED}Error: Invalid invite code format${NC}"
      echo "Expected format: subdomain:code (e.g., bob-rietveld:secret123)"
      exit 1
    fi
    INVITE_SUBDOMAIN="${INVITE_CODE%%:*}"
    REGISTRATION_CODE="${INVITE_CODE#*:}"
    WORKER_URL="https://bassh-api.${INVITE_SUBDOMAIN}.workers.dev"
  fi

  # Check worker URL is configured
  if [[ -z "$WORKER_URL" ]]; then
    echo -e "${RED}Error: Worker URL not configured${NC}"
    echo ""
    echo "Either use an invite code:"
    echo "  bassh register <username> --invite <subdomain:code>"
    echo ""
    echo "Or set your worker URL:"
    echo "  export BASSH_API=https://your-worker.workers.dev"
    exit 1
  fi

  # Get machine ID for one-account-per-computer
  MACHINE_ID=$(get_machine_id)

  # Check for registration code (if not from invite code)
  if [[ -z "$REGISTRATION_CODE" ]]; then
    if [[ -n "$BASSH_REGISTRATION_CODE" ]]; then
      REGISTRATION_CODE="$BASSH_REGISTRATION_CODE"
    else
      echo -n -e "${YELLOW}Registration code (press Enter if none): ${NC}"
      read -r REGISTRATION_CODE
    fi
  fi

  echo -e "${BLUE}Registering...${NC}"

  RESPONSE=$(curl -s -X POST "$WORKER_URL/register" \
    -H "Content-Type: application/json" \
    -d "{\"username\": \"$REGISTER_USERNAME\", \"registrationCode\": \"$REGISTRATION_CODE\", \"machineId\": \"$MACHINE_ID\"}") || true

  if [[ -z "$RESPONSE" ]]; then
    echo -e "${RED}Error: No response from server${NC}"
    exit 1
  fi

  if echo "$RESPONSE" | grep -q '"success":true'; then
    API_KEY=$(echo "$RESPONSE" | grep -oE '"key":"[^"]+"' | cut -d'"' -f4)

    # Determine shell config file
    if [[ -f "$HOME/.zshrc" ]]; then
      SHELL_RC="$HOME/.zshrc"
    else
      SHELL_RC="$HOME/.bashrc"
    fi

    # Auto-save configuration
    sed -i '' '/BASSH_KEY/d' "$SHELL_RC" 2>/dev/null || sed -i '/BASSH_KEY/d' "$SHELL_RC"
    echo "export BASSH_KEY=\"$API_KEY\"" >> "$SHELL_RC"

    # Also save URL if using invite code
    if [[ -n "$INVITE_CODE" ]]; then
      sed -i '' '/BASSH_API/d' "$SHELL_RC" 2>/dev/null || sed -i '/BASSH_API/d' "$SHELL_RC"
      echo "export BASSH_API=\"$WORKER_URL\"" >> "$SHELL_RC"
    fi

    echo ""
    echo -e "${GREEN}✓ Registered as ${REGISTER_USERNAME}${NC}"
    echo ""
    echo -e "  Configuration saved to ${CYAN}$SHELL_RC${NC}"
    echo ""
    echo -e "  ${BLUE}Ready to deploy:${NC}"
    echo -e "    source $SHELL_RC"
    echo -e "    bassh ./my-folder"
    echo ""
  else
    ERROR=$(echo "$RESPONSE" | grep -oE '"error":"[^"]+"' | cut -d'"' -f4)
    echo -e "${RED}Registration failed: $ERROR${NC}"
    exit 1
  fi
  exit 0
fi

# Handle me mode
if [[ "$ME_MODE" == true ]]; then
  MACHINE_ID=$(get_machine_id)

  RESPONSE=$(curl -s -X GET "$WORKER_URL/me" \
    -H "X-Machine-ID: $MACHINE_ID" \
    -H "X-API-Key: $API_KEY")

  if echo "$RESPONSE" | grep -q '"success":true'; then
    USERNAME=$(echo "$RESPONSE" | grep -oE '"username":"[^"]+"' | cut -d'"' -f4)
    CREATED=$(echo "$RESPONSE" | grep -oE '"created":"[^"]+"' | cut -d'"' -f4)
    INVITE_CODE=$(echo "$RESPONSE" | grep -oE '"inviteCode":"[^"]+"' | cut -d'"' -f4)
    echo ""
    echo -e "${GREEN}Logged in as:${NC} $USERNAME"
    echo -e "${BLUE}API:${NC} $WORKER_URL"
    echo -e "${BLUE}Domain:${NC} ${USERNAME}-{project}.pages.dev"
    if [[ -n "$INVITE_CODE" ]]; then
      echo -e "${BLUE}Invite:${NC} $INVITE_CODE"
    fi
    echo -e "${BLUE}Created:${NC} $CREATED"
    echo ""
  else
    echo -e "${RED}Not logged in${NC}"
    echo ""
    echo "Register this machine:"
    echo "  bassh register <username>"
    exit 1
  fi
  exit 0
fi

# Handle key mode
if [[ "$KEY_MODE" == true ]]; then
  MACHINE_ID=$(get_machine_id)

  if [[ "$KEY_REGENERATE" == true ]]; then
    # Regenerate API key
    echo -e "${YELLOW}Regenerating API key...${NC}"
    echo -e "${RED}Warning: Your old API key will stop working immediately.${NC}"
    echo ""
    echo -n -e "${YELLOW}Continue? (y/N): ${NC}"
    read -r CONFIRM
    if [[ "$CONFIRM" != "y" && "$CONFIRM" != "Y" ]]; then
      echo -e "${BLUE}Cancelled.${NC}"
      exit 0
    fi

    RESPONSE=$(curl -s -X POST "$WORKER_URL/key" \
      -H "X-Machine-ID: $MACHINE_ID" \
      -H "X-API-Key: $API_KEY" \
      -H "Content-Type: application/json")
  else
    # Get current API key
    RESPONSE=$(curl -s -X GET "$WORKER_URL/key" \
      -H "X-Machine-ID: $MACHINE_ID" \
      -H "X-API-Key: $API_KEY")
  fi

  if echo "$RESPONSE" | grep -q '"success":true'; then
    USERNAME=$(echo "$RESPONSE" | grep -oE '"username":"[^"]+"' | cut -d'"' -f4)
    KEY=$(echo "$RESPONSE" | grep -oE '"key":"[^"]+"' | cut -d'"' -f4)
    echo ""
    echo -e "${GREEN}Username:${NC} $USERNAME"
    echo -e "${GREEN}API Key:${NC}  $KEY"
    echo ""

    if [[ "$KEY_REGENERATE" == true ]]; then
      # Offer to update shell config
      if [[ -f "$HOME/.zshrc" ]]; then
        SHELL_RC="$HOME/.zshrc"
      else
        SHELL_RC="$HOME/.bashrc"
      fi

      echo -n -e "${YELLOW}Update API key in $SHELL_RC? (Y/n): ${NC}"
      read -r UPDATE_KEY
      if [[ "$UPDATE_KEY" != "n" && "$UPDATE_KEY" != "N" ]]; then
        sed -i '' '/BASSH_KEY/d' "$SHELL_RC" 2>/dev/null || sed -i '/BASSH_KEY/d' "$SHELL_RC"
        echo "export BASSH_KEY=\"$KEY\"" >> "$SHELL_RC"
        echo -e "${GREEN}✓ API key updated in $SHELL_RC${NC}"
        echo ""
        echo -e "Run: ${CYAN}source $SHELL_RC${NC}"
      fi
    fi
    echo ""
  else
    ERROR=$(echo "$RESPONSE" | grep -oE '"error":"[^"]+"' | cut -d'"' -f4)
    if [[ -n "$ERROR" ]]; then
      echo -e "${RED}$ERROR${NC}"
    else
      echo -e "${RED}Failed to get API key${NC}"
    fi
    exit 1
  fi
  exit 0
fi

# Handle forms mode
if [[ "$FORMS_MODE" == true ]]; then
  if [[ -z "$PROJECT_NAME" ]]; then
    echo -e "${RED}Error: Project name required. Use -n <name>${NC}"
    echo ""
    echo "Usage: bassh forms -n <project-name> [options]"
    echo ""
    echo "Options:"
    echo "  --json    Export as JSON"
    echo "  --csv     Export as CSV"
    echo "  --count   Show count only"
    echo "  --clear   Delete all submissions"
    exit 1
  fi

  MACHINE_ID=$(get_machine_id)

  # Handle clear
  if [[ "$FORMS_CLEAR" == true ]]; then
    echo -e "${YELLOW}Delete all form submissions for '$PROJECT_NAME'? (y/N)${NC}"
    echo -n "> "
    read -r CONFIRM < /dev/tty
    if [[ "$CONFIRM" != "y" && "$CONFIRM" != "Y" ]]; then
      echo -e "${BLUE}Cancelled.${NC}"
      exit 0
    fi

    RESPONSE=$(curl -s -X DELETE "$WORKER_URL/forms" \
      -H "X-Machine-ID: $MACHINE_ID" \
      -H "X-API-Key: $API_KEY" \
      -H "X-Project-Name: $PROJECT_NAME")

    if echo "$RESPONSE" | grep -q '"success":true'; then
      DELETED=$(echo "$RESPONSE" | grep -oE '"deleted":[0-9]+' | cut -d':' -f2)
      echo -e "${GREEN}✓ Deleted $DELETED submission(s)${NC}"
    else
      ERROR=$(echo "$RESPONSE" | grep -oE '"error":"[^"]+"' | cut -d'"' -f4)
      echo -e "${RED}Error: ${ERROR:-Failed to delete submissions}${NC}"
      exit 1
    fi
    exit 0
  fi

  # List forms
  RESPONSE=$(curl -s -X GET "$WORKER_URL/forms" \
    -H "X-Machine-ID: $MACHINE_ID" \
    -H "X-API-Key: $API_KEY" \
    -H "X-Project-Name: $PROJECT_NAME")

  if ! echo "$RESPONSE" | grep -q '"success":true'; then
    ERROR=$(echo "$RESPONSE" | grep -oE '"error":"[^"]+"' | cut -d'"' -f4)
    echo -e "${RED}Error: ${ERROR:-Failed to list submissions}${NC}"
    exit 1
  fi

  COUNT=$(echo "$RESPONSE" | grep -oE '"count":[0-9]+' | cut -d':' -f2)

  # Handle count only
  if [[ "$FORMS_COUNT" == true ]]; then
    echo "$COUNT"
    exit 0
  fi

  # Handle JSON output
  if [[ "$FORMS_FORMAT" == "json" ]]; then
    echo "$RESPONSE" | python3 -c "import sys,json; d=json.load(sys.stdin); print(json.dumps(d.get('submissions',[]),indent=2))" 2>/dev/null || echo "$RESPONSE"
    exit 0
  fi

  # Handle CSV output
  if [[ "$FORMS_FORMAT" == "csv" ]]; then
    echo "$RESPONSE" | python3 -c "
import sys, json, csv

data = json.load(sys.stdin)
submissions = data.get('submissions', [])

if not submissions:
    sys.exit(0)

# Collect all unique data field keys
all_keys = set()
for s in submissions:
    all_keys.update(s.get('data', {}).keys())
all_keys = sorted(all_keys)

# Write CSV
writer = csv.writer(sys.stdout)
writer.writerow(['_submitted'] + list(all_keys))

for s in submissions:
    row = [s.get('_meta', {}).get('submitted', '')]
    for key in all_keys:
        row.append(s.get('data', {}).get(key, ''))
    writer.writerow(row)
" 2>/dev/null
    exit 0
  fi

  # Default: human readable output
  echo ""
  echo -e "${GREEN}Submissions for $PROJECT_NAME ($COUNT total):${NC}"
  echo ""

  if [[ "$COUNT" == "0" ]]; then
    echo -e "  ${BLUE}No submissions yet.${NC}"
    echo ""
    exit 0
  fi

  # Parse and display submissions
  echo "$RESPONSE" | python3 -c "
import sys, json

data = json.load(sys.stdin)
submissions = data.get('submissions', [])

for i, s in enumerate(submissions, 1):
    meta = s.get('_meta', {})
    submitted = meta.get('submitted', 'Unknown')
    print(f'#{i} - {submitted}')
    for key, value in s.get('data', {}).items():
        print(f'  {key}: {value}')
    print()
" 2>/dev/null

  exit 0
fi

# Get machine ID for authentication
MACHINE_ID=$(get_machine_id)

# Handle uninstall mode
if [[ "$UNINSTALL_MODE" == true ]]; then
  # Get user info first
  ME_RESPONSE=$(curl -s -X GET "$WORKER_URL/me" \
    -H "X-Machine-ID: $MACHINE_ID" \
    -H "X-API-Key: $API_KEY")

  if ! echo "$ME_RESPONSE" | grep -q '"success":true'; then
    echo -e "${RED}Not logged in${NC}"
    echo ""
    echo "Register this machine first:"
    echo "  bassh register <username>"
    exit 1
  fi

  USERNAME=$(echo "$ME_RESPONSE" | grep -oE '"username":"[^"]+"' | cut -d'"' -f4)

  # Get projects for display
  LIST_RESPONSE=$(curl -s -X GET "$WORKER_URL" \
    -H "X-Machine-ID: $MACHINE_ID" \
    -H "X-API-Key: $API_KEY")

  echo ""
  echo -e "${RED}════════════════════════════════════════${NC}"
  echo -e "${RED}       UNINSTALL bassh${NC}"
  echo -e "${RED}════════════════════════════════════════${NC}"
  echo ""
  echo -e "${YELLOW}This will permanently delete:${NC}"
  echo ""
  echo -e "  ${BLUE}•${NC} Your account: ${CYAN}$USERNAME${NC}"

  # Show projects if any
  if echo "$LIST_RESPONSE" | grep -q '"shortName"'; then
    echo -e "  ${BLUE}•${NC} All your Cloudflare Pages projects:"
    echo "$LIST_RESPONSE" | grep -oE '"shortName":"[^"]+"' | cut -d'"' -f4 | while read -r name; do
      echo -e "      - $name"
    done
  fi

  echo -e "  ${BLUE}•${NC} Associated Cloudflare Access policies"
  echo -e "  ${BLUE}•${NC} Your API key from shell config"
  echo ""
  echo -e "${RED}This action cannot be undone!${NC}"
  echo ""
  echo -n -e "${YELLOW}Type 'DELETE' to confirm: ${NC}"
  read -r CONFIRM

  if [[ "$CONFIRM" != "DELETE" ]]; then
    echo -e "${BLUE}Uninstall cancelled.${NC}"
    exit 0
  fi

  echo ""
  echo -e "${BLUE}Removing cloud resources...${NC}"

  RESPONSE=$(curl -s -X POST "$WORKER_URL/uninstall" \
    -H "X-Machine-ID: $MACHINE_ID" \
    -H "X-API-Key: $API_KEY" \
    -H "Content-Type: application/json")

  if echo "$RESPONSE" | grep -q '"success":true'; then
    PROJECTS_COUNT=$(echo "$RESPONSE" | grep -oE '"projectsCount":[0-9]+' | cut -d':' -f2)
    APPS_COUNT=$(echo "$RESPONSE" | grep -oE '"appsCount":[0-9]+' | cut -d':' -f2)

    echo -e "${GREEN}✓ Deleted $PROJECTS_COUNT project(s)${NC}"
    echo -e "${GREEN}✓ Deleted $APPS_COUNT access app(s)${NC}"
    echo -e "${GREEN}✓ Deleted user account${NC}"

    # Remove API key from shell config
    if [[ -f "$HOME/.zshrc" ]]; then
      SHELL_RC="$HOME/.zshrc"
    else
      SHELL_RC="$HOME/.bashrc"
    fi

    if grep -q "BASSH_KEY" "$SHELL_RC" 2>/dev/null; then
      sed -i '' '/BASSH_KEY/d' "$SHELL_RC" 2>/dev/null || sed -i '/BASSH_KEY/d' "$SHELL_RC"
      echo -e "${GREEN}✓ Removed API key from $SHELL_RC${NC}"
    fi

    # Remove local machine ID
    if [[ -f "$MACHINE_ID_FILE" ]]; then
      rm -f "$MACHINE_ID_FILE"
      echo -e "${GREEN}✓ Removed machine ID${NC}"
    fi
    # Remove config directory if empty
    rmdir "$CONFIG_DIR" 2>/dev/null || true

    echo ""
    echo -n -e "${YELLOW}Remove CLI script from system? (y/N): ${NC}"
    read -r REMOVE_CLI

    if [[ "$REMOVE_CLI" == "y" || "$REMOVE_CLI" == "Y" ]]; then
      CLI_PATH=$(which bassh 2>/dev/null || echo "")
      if [[ -n "$CLI_PATH" && -f "$CLI_PATH" ]]; then
        rm -f "$CLI_PATH" 2>/dev/null && echo -e "${GREEN}✓ Removed CLI from $CLI_PATH${NC}" || echo -e "${YELLOW}Could not remove $CLI_PATH (may need sudo)${NC}"
      else
        echo -e "${BLUE}CLI not found in PATH, skipping${NC}"
      fi
    fi

    echo ""
    echo -e "${GREEN}════════════════════════════════════════${NC}"
    echo -e "${GREEN}Uninstall complete!${NC}"
    echo -e "${GREEN}════════════════════════════════════════${NC}"
    echo ""
  else
    ERROR=$(echo "$RESPONSE" | grep -oE '"error":"[^"]+"' | cut -d'"' -f4)
    echo -e "${RED}Uninstall failed: $ERROR${NC}"
    echo "Response: $RESPONSE"
    exit 1
  fi
  exit 0
fi

# Handle list mode
if [[ "$LIST_MODE" == true ]]; then
  RESPONSE=$(curl -s -X GET "$WORKER_URL" \
    -H "X-Machine-ID: $MACHINE_ID" \
    -H "X-API-Key: $API_KEY")

  if echo "$RESPONSE" | grep -q '"success":true'; then
    USERNAME=$(echo "$RESPONSE" | grep -oE '"username":"[^"]+"' | cut -d'"' -f4)
    echo -e "${GREEN}Projects for $USERNAME:${NC}"
    echo ""

    # Parse projects using Python for reliable JSON handling
    echo "$RESPONSE" | python3 -c "
import sys, json
data = json.load(sys.stdin)
for p in data.get('projects', []):
    name = p.get('shortName', p.get('name', ''))
    url = p.get('url', '')
    custom = p.get('customDomain')
    if custom:
        print(f'  \033[0;34m•\033[0m {name}')
        print(f'    \033[0;36m{url}\033[0m \033[0;33m(custom domain)\033[0m')
    else:
        print(f'  \033[0;34m•\033[0m {name}')
        print(f'    \033[0;36m{url}\033[0m')
"
    echo ""
  else
    ERROR=$(echo "$RESPONSE" | grep -oE '"error":"[^"]+"' | cut -d'"' -f4)
    if [[ -n "$ERROR" ]]; then
      echo -e "${RED}$ERROR${NC}"
    else
      echo -e "${RED}Failed to list projects${NC}"
    fi
    exit 1
  fi
  exit 0
fi

# Handle delete mode
if [[ "$DELETE_MODE" == true ]]; then
  if [[ -z "$PROJECT_NAME" ]]; then
    echo -e "${RED}Error: Project name required for delete. Use -n <name>${NC}"
    exit 1
  fi

  echo -e "${BLUE}Deleting project: $PROJECT_NAME${NC}"

  RESPONSE=$(curl -s -X DELETE "$WORKER_URL" \
    -H "Content-Type: application/json" \
    -H "X-Machine-ID: $MACHINE_ID" \
    -H "X-API-Key: $API_KEY" \
    -H "X-Project-Name: $PROJECT_NAME")

  if echo "$RESPONSE" | grep -q '"success":true'; then
    echo -e "${GREEN}✓ Project '$PROJECT_NAME' deleted successfully${NC}"
  else
    echo -e "${RED}Delete failed${NC}"
    echo "Response: $RESPONSE"
    exit 1
  fi
  exit 0
fi

# Check if directory exists
if [[ ! -d "$DIR" ]]; then
  echo -e "${RED}Error: Directory '$DIR' not found${NC}"
  exit 1
fi

# Check for required tools
if ! command -v curl &> /dev/null; then
  echo -e "${RED}Error: 'curl' command not found. Please install it.${NC}"
  exit 1
fi

if ! command -v base64 &> /dev/null; then
  echo -e "${RED}Error: 'base64' command not found. Please install it.${NC}"
  exit 1
fi

# Generate project name if not provided
if [[ -z "$PROJECT_NAME" ]]; then
  PROJECT_NAME="site-$(date +%s | tail -c 6)"
fi

# Validate project name (Cloudflare naming rules)
# - 1-58 lowercase characters
# - Can contain dashes
# - Cannot start or end with a dash
validate_project_name() {
  local name="$1"

  # Check length (1-58)
  if [[ ${#name} -lt 1 || ${#name} -gt 58 ]]; then
    return 1
  fi

  # Check for valid characters (lowercase letters, numbers, dashes)
  if [[ ! "$name" =~ ^[a-z0-9-]+$ ]]; then
    return 1
  fi

  # Check doesn't start or end with dash
  if [[ "$name" == -* || "$name" == *- ]]; then
    return 1
  fi

  return 0
}

if ! validate_project_name "$PROJECT_NAME"; then
  echo -e "${RED}Error: Invalid project name '$PROJECT_NAME'${NC}"
  echo ""
  echo "Project names must be:"
  echo "  • 1-58 characters long"
  echo "  • Lowercase letters, numbers, and dashes only"
  echo "  • Cannot start or end with a dash"
  echo ""
  echo "Example: my-project-123"
  exit 1
fi

# Validate custom domain if provided
validate_domain() {
  local domain="$1"
  # Basic validation: alphanumeric, dots, dashes, valid TLD
  if [[ ! "$domain" =~ ^[a-zA-Z0-9]([a-zA-Z0-9-]*[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9-]*[a-zA-Z0-9])?)*\.[a-zA-Z]{2,}$ ]]; then
    return 1
  fi
  return 0
}

if [[ -n "$CUSTOM_DOMAIN" ]]; then
  if ! validate_domain "$CUSTOM_DOMAIN"; then
    echo -e "${RED}Error: Invalid domain format '$CUSTOM_DOMAIN'${NC}"
    echo ""
    echo "Examples of valid domains:"
    echo "  • docs.example.com"
    echo "  • www.example.com"
    echo "  • example.com"
    exit 1
  fi
fi

# Create temp directory for processing
TEMP_DIR=$(mktemp -d)
DEPLOY_DIR="$TEMP_DIR/deploy"
JSON_FILE="$TEMP_DIR/payload.json"

mkdir -p "$DEPLOY_DIR"

# Copy files
cp -r "$DIR"/* "$DEPLOY_DIR"/ 2>/dev/null || cp -r "$DIR"/. "$DEPLOY_DIR"/

# Auto-create index.html if missing
if [[ ! -f "$DEPLOY_DIR/index.html" ]]; then
  FIRST_HTML=$(find "$DEPLOY_DIR" -maxdepth 1 -name "*.html" -type f | head -1)
  if [[ -n "$FIRST_HTML" ]]; then
    cp "$FIRST_HTML" "$DEPLOY_DIR/index.html"
    echo -e "${BLUE}No index.html found, using $(basename "$FIRST_HTML")${NC}"
  fi
fi

# Password protection is now handled server-side with AES-256-GCM encryption
if [[ -n "$PASSWORD" ]]; then
  echo -e "${BLUE}Password protection enabled (AES-256-GCM encryption)${NC}"
fi

# Build JSON payload with files
echo -e "${BLUE}Packaging site...${NC}"

cd "$DEPLOY_DIR"

# Collect all files into an array
FILES=()
while IFS= read -r -d '' file; do
  FILES+=("$file")
done < <(find . -type f -print0)

# Build JSON
echo -n '{"files":[' > "$JSON_FILE"

for i in "${!FILES[@]}"; do
  file="${FILES[$i]}"
  # Remove leading ./
  FILEPATH="${file#./}"

  # Base64 encode the file content
  CONTENT=$(base64 < "$file" | tr -d '\n')

  if [ $i -gt 0 ]; then
    echo -n "," >> "$JSON_FILE"
  fi

  # Write JSON object
  printf '{"path":"%s","content":"%s"}' "$FILEPATH" "$CONTENT" >> "$JSON_FILE"
done

echo ']}' >> "$JSON_FILE"

cd - > /dev/null

# Upload to worker
echo -e "${BLUE}Deploying to Cloudflare Pages...${NC}"
echo ""

RESPONSE=$(curl -s -X POST "$WORKER_URL" \
  -H "Content-Type: application/json" \
  -H "X-Machine-ID: $MACHINE_ID" \
  -H "X-API-Key: $API_KEY" \
  -H "X-Project-Name: $PROJECT_NAME" \
  -H "X-Password: $PASSWORD" \
  -H "X-Emails: $EMAILS" \
  -H "X-Domain: $DOMAIN" \
  -H "X-Custom-Domain: $CUSTOM_DOMAIN" \
  -H "X-OTP-Emails: $OTP_EMAILS" \
  --data-binary "@$JSON_FILE")

# Cleanup
rm -rf "$TEMP_DIR"

# Parse response
if echo "$RESPONSE" | grep -q '"success":true'; then
  URL=$(echo "$RESPONSE" | grep -oE '"url":"[^"]+' | head -1 | cut -d'"' -f4)
  PROJECT=$(echo "$RESPONSE" | grep -oE '"project":"[^"]+' | cut -d'"' -f4)
  SHORT_NAME=$(echo "$RESPONSE" | grep -oE '"shortName":"[^"]+' | cut -d'"' -f4)

  echo -e "${GREEN}════════════════════════════════════════${NC}"
  echo -e "${GREEN}✓ Site deployed successfully!${NC}"
  echo -e "${GREEN}════════════════════════════════════════${NC}"
  echo ""
  echo -e "  ${BLUE}URL:${NC} $URL"
  echo -e "  ${BLUE}Project:${NC} $SHORT_NAME"

  if [[ -n "$PASSWORD" ]]; then
    echo -e "  ${BLUE}Password:${NC} $PASSWORD"
  fi

  if [[ -n "$EMAILS" ]]; then
    echo -e "  ${BLUE}Allowed emails:${NC} $EMAILS"
  fi

  if [[ -n "$DOMAIN" ]]; then
    echo -e "  ${BLUE}Allowed domain:${NC} $DOMAIN"
  fi

  if [[ -n "$OTP_EMAILS" ]]; then
    echo -e "  ${BLUE}Email access:${NC} $OTP_EMAILS"
    echo ""
    echo -e "  ${CYAN}Visitors enter their email and receive a magic link.${NC}"
  fi

  if [[ -n "$EMAILS" || -n "$DOMAIN" ]]; then
    echo ""
    echo -e "  ${CYAN}Visitors will verify via Cloudflare Access.${NC}"
  fi

  # Display custom domain info if configured
  if [[ -n "$CUSTOM_DOMAIN" ]]; then
    CNAME_TARGET=$(echo "$RESPONSE" | grep -oE '"cname":"[^"]+"' | cut -d'"' -f4)
    DOMAIN_STATUS=$(echo "$RESPONSE" | grep -oE '"status":"[^"]+"' | head -1 | cut -d'"' -f4)
    DOMAIN_ERROR=$(echo "$RESPONSE" | grep -oE '"customDomain":\{[^}]*"error":"[^"]+"' | grep -oE '"error":"[^"]+"' | cut -d'"' -f4)

    echo ""
    echo -e "  ${BLUE}Custom domain:${NC} $CUSTOM_DOMAIN"

    if [[ -n "$DOMAIN_ERROR" ]]; then
      echo -e "  ${RED}Error:${NC} $DOMAIN_ERROR"
    else
      echo -e "  ${BLUE}Status:${NC} ${DOMAIN_STATUS:-pending}"
      echo ""
      echo -e "  ${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
      echo -e "  ${YELLOW}Add this DNS record at your domain provider:${NC}"
      echo -e "  ${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
      echo ""

      # Check if root domain or subdomain
      if [[ "$CUSTOM_DOMAIN" =~ ^[^.]+\.[^.]+$ ]]; then
        # Root domain (e.g., example.com)
        echo -e "  ${CYAN}For Cloudflare DNS:${NC}"
        echo -e "    Type:  ${GREEN}CNAME${NC}"
        echo -e "    Name:  ${GREEN}@${NC}"
        echo -e "    Value: ${GREEN}${CNAME_TARGET:-$PROJECT.$SHORT_NAME.pages.dev}${NC}"
        echo ""
        echo -e "  ${CYAN}For other DNS providers:${NC}"
        echo -e "    Use ALIAS/ANAME record, or redirect to www"
      else
        # Subdomain (e.g., docs.example.com, www.example.com)
        SUBDOMAIN="${CUSTOM_DOMAIN%%.*}"
        echo -e "    Type:  ${GREEN}CNAME${NC}"
        echo -e "    Name:  ${GREEN}$SUBDOMAIN${NC}"
        echo -e "    Value: ${GREEN}${CNAME_TARGET:-$PROJECT.pages.dev}${NC}"
      fi

      echo ""
      echo -e "  Once DNS is configured, ${CYAN}https://$CUSTOM_DOMAIN${NC} will be live."
      echo -e "  ${BLUE}(SSL is provisioned automatically by Cloudflare)${NC}"
    fi
  fi

  echo ""
else
  echo -e "${RED}Deployment failed${NC}"
  echo ""
  echo "Response: $RESPONSE"
  exit 1
fi
